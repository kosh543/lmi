Final timings as of 2020-09-16:

32-bit valyuta/002 commit d124022d
  naic, no solve      : 1.025e-01 s mean;     102020 us least of  10 runs
  naic, specamt solve : 1.796e-01 s mean;     179040 us least of   6 runs
  naic, ee prem solve : 1.787e-01 s mean;     162828 us least of   6 runs
  finra, no solve     : 2.663e-02 s mean;      26256 us least of  38 runs
  finra, specamt solve: 9.554e-02 s mean;      94678 us least of  11 runs
  finra, ee prem solve: 8.758e-02 s mean;      86966 us least of  12 runs

64-bit valyuta/002 commit d124022d
  naic, no solve      : 3.514e-02 s mean;      34749 us least of  29 runs
  naic, specamt solve : 5.748e-02 s mean;      56785 us least of  18 runs
  naic, ee prem solve : 5.316e-02 s mean;      52317 us least of  19 runs
  finra, no solve     : 1.500e-02 s mean;      14669 us least of  67 runs
  finra, specamt solve: 3.501e-02 s mean;      34537 us least of  29 runs
  finra, ee prem solve: 3.414e-02 s mean;      32419 us least of  30 runs

32-bit origin/master commit 3023433f

  naic, no solve      : 5.199e-02 s mean;      51227 us least of  20 runs
  naic, specamt solve : 9.311e-02 s mean;      92312 us least of  11 runs
  naic, ee prem solve : 8.570e-02 s mean;      84947 us least of  12 runs
  finra, no solve     : 2.110e-02 s mean;      20654 us least of  48 runs
  finra, specamt solve: 5.881e-02 s mean;      58151 us least of  18 runs
  finra, ee prem solve: 5.471e-02 s mean;      54206 us least of  19 runs

64-bit origin/master commit 3023433f
  naic, no solve      : 2.502e-02 s mean;      24783 us least of  40 runs
  naic, specamt solve : 4.071e-02 s mean;      40252 us least of  25 runs
  naic, ee prem solve : 3.776e-02 s mean;      37410 us least of  27 runs
  finra, no solve     : 1.323e-02 s mean;      13009 us least of  76 runs
  finra, specamt solve: 2.796e-02 s mean;      27122 us least of  36 runs
  finra, ee prem solve: 2.669e-02 s mean;      26127 us least of  38 runs

tabulating more compactly:

  valyuta, master, ratio: 32 bit

   102020   51227   1.99 [scenarios in same order as above]
   179040   92312   1.94
   162828   84947   1.92
    26256   20654   1.27
    94678   58151   1.63
    86966   54206   1.60

  valyuta, master, ratio: 64 bit
    34749   24783   1.40
    56785   40252   1.41
    52317   37410   1.40
    14669   13009   1.13
    34537   27122   1.27
    32419   26127   1.24

The first three rows of each set of six are the most important, because
they are the most solve-heavy.

At first, it seemed that the solve-free fourth scenario might represent
the true system speed, and that the other five scenarios demonstrated
some unexplained penalty for solves, which we might have hoped to reduce
or eliminate. However, the immediately-preceding commit showed that hope
to be forlorn: to within the expected representation error for formatted
numbers such as
  iteration 17 iterand 1879003 value 136.140000000828877091 vs.
  iteration 17 iterand 1879003 value 136.139999999999986358
the traces of each solve iteration are identical. In reality, therefore,
producing an illustration means
  do_lots_of_setup(based_on_input)
  for each basis in {current, guaranteed, midpoint} (e.g.)
    call RunOneCell()
  do_lots_of_output()
while solves just invoke RunOneCell() iteratively, so the fourth
scenario above measures the ratio of
  one-time setup and output, plus about three calls to RunOneCell()
while the second and third compare
  one-time setup and output, plus about fifty calls to RunOneCell()
The conclusion is that using the currency class imposes a speed
penalty in the code that uses it (i.e., RunOneCell()) of about one
hundred percent for 32- and forty percent for 64-bit builds.

The reason is that lmi quantities are mostly integer-valued, but they're
heavily dependent on floating-point calculations--for example:
  monthly_interest_factor const = (1.04)^(1/12) - 1
  old_value = $1,234.56
  new_value = old_value + round_to_cents(old_value * monthly_interest_factor)
At least in the present experimental branch, this is realized as if by:
  double floating_old_value = static_cast<double>(100.0 * old_value)
  double floating_increment = floating_old_value * monthly_interest_factor
  new_value += round_to_cents(floating_increment / 100.0)
It's certainly possible to rewrite the code to avoid multiplying and
dividing by 100.0 repeatedly, although the effort would be considerable.
But it is not possible to maintain values as integer and never transform
them to floating-point and back--so, if such transformations are inherently
very costly, then there's no way to avoid a penalty.

OTOH, instead of an integer type like std::int64_t, we might use scaled,
integer-valued doubles--e.g., instead of the problematic
  double old_value = 1234.56; // actually 1234.55999999xyz
we could store
  double old_value = 123456;  // exactly  123456.0000000000000000

If we're going to use a currency class, we should make the switch before
this branch rots. Taking the third scenario above as representative:
  valyuta, master
   162828   84947  32 bit
    52317   37410  64 bit
we can't go from 84947 us to 162828 us directly, because end users would
not view that favorably. But we could go from 84947 to 52317 (releasing
a currency-based 64-bit build to replace 32-bit master), and then make
incremental improvements at our leisure. However, it's hard to tell
whether the 'currency' penalty can be made close to zero, or possibly
negative; if it can't, then is a currency class worth the bother? Pros:
 - currency is natural in the problem domain
 - it avoids some nasty catastrophic-cancellation issues
Cons:
 - it makes the code less clear
 - it imposes a performance penalty that may turn out to be inherent

//

64-bit valyuta/002 commit 49f84a1e
  naic, no solve      : 3.517e-02 s mean;      34812 us least of  29 runs
  naic, specamt solve : 5.662e-02 s mean;      55880 us least of  18 runs
  naic, ee prem solve : 5.393e-02 s mean;      53008 us least of  19 runs
  finra, no solve     : 1.500e-02 s mean;      14688 us least of  67 runs
  finra, specamt solve: 3.411e-02 s mean;      33652 us least of  30 runs
  finra, ee prem solve: 3.436e-02 s mean;      32527 us least of  30 runs

64-bit origin/master commit 6a05bcee
  naic, no solve      : 2.566e-02 s mean;      25448 us least of  39 runs
  naic, specamt solve : 4.102e-02 s mean;      40694 us least of  25 runs
  naic, ee prem solve : 3.809e-02 s mean;      37757 us least of  27 runs
  finra, no solve     : 1.384e-02 s mean;      13679 us least of  73 runs
  finra, specamt solve: 2.790e-02 s mean;      27633 us least of  36 runs
  finra, ee prem solve: 2.631e-02 s mean;      26060 us least of  39 runs

Thus, for 64-bit builds, the "currency" penalty is only about seven
percent for the plain "finra, no solve" scenario: much less bad than
the 32-bit results, perhaps because int64_t is the "natural" integer
size for 64-bit binaries. However, the penalty for scenarios with
solves is still high--especially for "naic" runs, which always have
an implicit solve for guaranteed premium, and may also have explicit
solves as indicated above.

//

More incremental improvement--as of commit 39d842f5d0:

  naic, no solve      : 1.065e-01 s mean;      99740 us least of  10 runs
  naic, specamt solve : 1.731e-01 s mean;     172259 us least of   6 runs
  naic, ee prem solve : 1.611e-01 s mean;     159984 us least of   7 runs
  finra, no solve     : 2.644e-02 s mean;      26227 us least of  38 runs
  finra, specamt solve: 9.114e-02 s mean;      90629 us least of  11 runs
  finra, ee prem solve: 8.721e-02 s mean;      86662 us least of  12 runs

//

Make conversions explicit, e.g.:
  currency amount;
- amount = 3.14;           // implicit
+ amount = currency(3.14); // explicit
  double floating;
- floating = amount;       // was implicit
+ floating = amount.d();
That may seem like mere ugly verbosity, but...
- amount = 0.0;            // (integer)(round(100.0 * 0.0))
+ amount = currency();     // integer = 0
+ currency amount {};      // even better, where possible
- if(0.0 == amount)        // 0.0 == (double)(amount / 100.0)
+ if(currency() == amount) // integer == integer
A user-defined literals like "0_c" could replace

Removed the very costly implicit conversions:
    currency& operator=(double d)
    operator double() const
but allowed
    currency& operator=(int i) // assigns 100.0 * argument

Because using integer math means not having to worry about catastrophic
cancellation, made improvements like this:

- LMI_ASSERT(materially_equal(GrossPmts[j], EeGrossPmts[j] + ErGrossPmts[j]));
+ LMI_ASSERT(GrossPmts[j] == EeGrossPmts[j] + ErGrossPmts[j]);

     double max_loan =
          AVUnloaned.d() * 0.9
        + (AVRegLn + AVPrfLn).d()
        - RegLnBal.d() * i_reg
        - PrfLnBal.d() * i_prf
        - mlydedtonextmodalpmtdate.d()
        ;

random notes--further cleanup and other future tasks:

unary operator-()

loads class should use currency type for policy fees

probably DCV should be currency instead of double

Solves are still a puzzle: is it inherently slower to find an
integral root than a floating-point root of a polynomial? That
question is crucial because making solves dramatically slower
could mean that a currency class is unaffordable.

After the changes in commit a32e29bb3cb:

  naic, no solve      : 1.085e-01 s mean;     103995 us least of  10 runs
  naic, specamt solve : 1.798e-01 s mean;     179138 us least of   6 runs
  naic, ee prem solve : 1.672e-01 s mean;     166277 us least of   6 runs
  finra, no solve     : 2.711e-02 s mean;      26542 us least of  37 runs
  finra, specamt solve: 9.375e-02 s mean;      93087 us least of  11 runs
  finra, ee prem solve: 8.994e-02 s mean;      89230 us least of  12 runs

which is about ten percent faster for "finra, no solve", the
only scenario that involves no explicit or implicit solve,
so these improvements are valuable even if making all the
conversions explicit impairs readability somewhat. Still,
solves need to be looked at. Compared to production, even with
these changes the currency branch is thirty percent slower for the
"finra, no solve" case (yet further improvements might bring that
into an acceptable range), but only half as fast for the "naic"
scenarios (which involve solves).

//

As of
  commit 7bac50c7154a419ff93a1398313dc7fe6d9fbed5 (HEAD -> valyuta/002)
  Date:   2020-09-13T23:50:07+00:00
the currency class adds considerable overhead: about 42% in the
"finra, no solve" case, and much more in the other cases, which all
involve solves (even "naic, no solve" has a guaranteed-premium solve).
Thus, solves need to be looked at.

production:

  naic, no solve      : 5.122e-02 s mean;      50922 us least of  20 runs
  naic, specamt solve : 9.235e-02 s mean;      91375 us least of  11 runs
  naic, ee prem solve : 8.451e-02 s mean;      83933 us least of  12 runs
  finra, no solve     : 2.068e-02 s mean;      20534 us least of  49 runs
  finra, specamt solve: 5.816e-02 s mean;      57775 us least of  18 runs
  finra, ee prem solve: 5.385e-02 s mean;      53643 us least of  19 runs

currency, without patch below:

Test speed:
  naic, no solve      : 1.248e-01 s mean;     123517 us least of   9 runs  2.43
  naic, specamt solve : 2.139e-01 s mean;     212435 us least of   5 runs  2.32
  naic, ee prem solve : 2.024e-01 s mean;     198110 us least of   5 runs  2.36
  finra, no solve     : 2.958e-02 s mean;      29122 us least of  34 runs  1.42
  finra, specamt solve: 1.087e-01 s mean;     107460 us least of  10 runs  1.86
  finra, ee prem solve: 1.041e-01 s mean;     102665 us least of  10 runs  1.91

currency, with patch below:

Test speed:
  naic, no solve      : 7.284e-02 s mean;      72125 us least of  14 runs  1.42
  naic, specamt solve : 1.317e-01 s mean;     130443 us least of   8 runs  1.43
  naic, ee prem solve : 1.190e-01 s mean;     117681 us least of   9 runs  1.40
  finra, no solve     : 2.360e-02 s mean;      23285 us least of  43 runs  1.13
  finra, specamt solve: 7.287e-02 s mean;      72060 us least of  14 runs  1.25
  finra, ee prem solve: 6.995e-02 s mean;      69262 us least of  15 runs  1.29

This patch causes serious regressions. Its purpose is only to show
the effect of removing as much overhead from class currency as seems
possible.

diff --git a/currency.hpp b/currency.hpp
index 0a54a917..20123047 100644
--- a/currency.hpp
+++ b/currency.hpp
@@ -64,8 +64,8 @@ class currency
     ~currency() = default;
 
     explicit currency(double    d) : m_ {from_double(d)}           {}
-    explicit currency(int       i) : m_ {bourn_cast<data_type>(i)} {}
-    explicit currency(data_type i) : m_ {bourn_cast<data_type>(i)} {}
+    explicit currency(int       i) : m_ {static_cast<data_type>(i)} {}
+    explicit currency(data_type i) : m_ {static_cast<data_type>(i)} {}
 
     currency& operator=(currency const&) = default;
     // IMPORTANT eventually suppress this? or both of these?
@@ -131,7 +131,7 @@ class currency
     // ...less bad:
 //  data_type from_double(double d) const {return bourn_cast<data_type>(round(cents_per_dollar * d));}
     data_type from_double(double d) const {return round(cents_per_dollar * d);}
-    double to_double() const {return bourn_cast<double>(m_) / cents_per_dollar;}
+    double to_double() const {return static_cast<double>(m_) / cents_per_dollar;}
 //  data_type from_double(double d) const {return static_cast<data_type>(cents_per_dollar * d);}
 //  double to_double() const {return static_cast<double>(m_) / cents_per_dollar;}
 #if 0 // will a fwd decl be wanted somewhere?
@@ -143,7 +143,8 @@ class currency
 #else // 1
     data_type round(double d) const
         {
-        return bourn_cast<data_type>(std::round(d));
+//      return bourn_cast<data_type>(std::round(d));
+        return static_cast<data_type>(d);
         }
 #endif // 1
     data_type m_ = {0};
diff --git a/round_to.hpp b/round_to.hpp
index 84772dc8..59c37d49 100644
--- a/round_to.hpp
+++ b/round_to.hpp
@@ -390,7 +390,7 @@ inline currency round_to<RealType>::c(RealType r) const
         (rounding_function_(static_cast<RealType>(r * scale_fwd_)) * scale_back_c_
         );
     // include required headers
-    return currency(bourn_cast<currency::data_type>(z));
+    return currency(static_cast<currency::data_type>(z));
 #if 0
     // don't do this in production:
     if(z != std::trunc(z))
