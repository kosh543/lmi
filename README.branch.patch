64-bit valyuta/002 commit 49f84a1e
  naic, no solve      : 3.517e-02 s mean;      34812 us least of  29 runs
  naic, specamt solve : 5.662e-02 s mean;      55880 us least of  18 runs
  naic, ee prem solve : 5.393e-02 s mean;      53008 us least of  19 runs
  finra, no solve     : 1.500e-02 s mean;      14688 us least of  67 runs
  finra, specamt solve: 3.411e-02 s mean;      33652 us least of  30 runs
  finra, ee prem solve: 3.436e-02 s mean;      32527 us least of  30 runs

64-bit origin/master commit 6a05bcee
  naic, no solve      : 2.566e-02 s mean;      25448 us least of  39 runs
  naic, specamt solve : 4.102e-02 s mean;      40694 us least of  25 runs
  naic, ee prem solve : 3.809e-02 s mean;      37757 us least of  27 runs
  finra, no solve     : 1.384e-02 s mean;      13679 us least of  73 runs
  finra, specamt solve: 2.790e-02 s mean;      27633 us least of  36 runs
  finra, ee prem solve: 2.631e-02 s mean;      26060 us least of  39 runs

Thus, for 64-bit builds, the "currency" penalty is only about seven
percent for the plain "finra, no solve" scenario: much less bad than
the 32-bit results, perhaps because int64_t is the "natural" integer
size for 64-bit binaries. However, the penalty for scenarios with
solves is still high--especially for "naic" runs, which always have
an implicit solve for guaranteed premium, and may also have explicit
solves as indicated above.

//

More incremental improvement--as of commit 39d842f5d0:

  naic, no solve      : 1.065e-01 s mean;      99740 us least of  10 runs
  naic, specamt solve : 1.731e-01 s mean;     172259 us least of   6 runs
  naic, ee prem solve : 1.611e-01 s mean;     159984 us least of   7 runs
  finra, no solve     : 2.644e-02 s mean;      26227 us least of  38 runs
  finra, specamt solve: 9.114e-02 s mean;      90629 us least of  11 runs
  finra, ee prem solve: 8.721e-02 s mean;      86662 us least of  12 runs

//

Make conversions explicit, e.g.:
  currency amount;
- amount = 3.14;           // implicit
+ amount = currency(3.14); // explicit
  double floating;
- floating = amount;       // was implicit
+ floating = amount.d();
That may seem like mere ugly verbosity, but...
- amount = 0.0;            // (integer)(round(100.0 * 0.0))
+ amount = currency();     // integer = 0
+ currency amount {};      // even better, where possible
- if(0.0 == amount)        // 0.0 == (double)(amount / 100.0)
+ if(currency() == amount) // integer == integer
A user-defined literals like "0_c" could replace

Removed the very costly implicit conversions:
    currency& operator=(double d)
    operator double() const
but allowed
    currency& operator=(int i) // assigns 100.0 * argument

Because using integer math means not having to worry about catastrophic
cancellation, made improvements like this:

- LMI_ASSERT(materially_equal(GrossPmts[j], EeGrossPmts[j] + ErGrossPmts[j]));
+ LMI_ASSERT(GrossPmts[j] == EeGrossPmts[j] + ErGrossPmts[j]);

     double max_loan =
          AVUnloaned.d() * 0.9
        + (AVRegLn + AVPrfLn).d()
        - RegLnBal.d() * i_reg
        - PrfLnBal.d() * i_prf
        - mlydedtonextmodalpmtdate.d()
        ;

random notes--further cleanup and other future tasks:

unary operator-()

loads class should use currency type for policy fees

probably DCV should be currency instead of double

Solves are still a puzzle: is it inherently slower to find an
integral root than a floating-point root of a polynomial? That
question is crucial because making solves dramatically slower
could mean that a currency class is unaffordable.

After the changes in commit a32e29bb3cb:

  naic, no solve      : 1.085e-01 s mean;     103995 us least of  10 runs
  naic, specamt solve : 1.798e-01 s mean;     179138 us least of   6 runs
  naic, ee prem solve : 1.672e-01 s mean;     166277 us least of   6 runs
  finra, no solve     : 2.711e-02 s mean;      26542 us least of  37 runs
  finra, specamt solve: 9.375e-02 s mean;      93087 us least of  11 runs
  finra, ee prem solve: 8.994e-02 s mean;      89230 us least of  12 runs

which is about ten percent faster for "finra, no solve", the
only scenario that involves no explicit or implicit solve,
so these improvements are valuable even if making all the
conversions explicit impairs readability somewhat. Still,
solves need to be looked at. Compared to production, even with
these changes the currency branch is thirty percent slower for the
"finra, no solve" case (yet further improvements might bring that
into an acceptable range), but only half as fast for the "naic"
scenarios (which involve solves).

//

As of
  commit 7bac50c7154a419ff93a1398313dc7fe6d9fbed5 (HEAD -> valyuta/002)
  Date:   2020-09-13T23:50:07+00:00
the currency class adds considerable overhead: about 42% in the
"finra, no solve" case, and much more in the other cases, which all
involve solves (even "naic, no solve" has a guaranteed-premium solve).
Thus, solves need to be looked at.

production:

  naic, no solve      : 5.122e-02 s mean;      50922 us least of  20 runs
  naic, specamt solve : 9.235e-02 s mean;      91375 us least of  11 runs
  naic, ee prem solve : 8.451e-02 s mean;      83933 us least of  12 runs
  finra, no solve     : 2.068e-02 s mean;      20534 us least of  49 runs
  finra, specamt solve: 5.816e-02 s mean;      57775 us least of  18 runs
  finra, ee prem solve: 5.385e-02 s mean;      53643 us least of  19 runs

currency, without patch below:

Test speed:
  naic, no solve      : 1.248e-01 s mean;     123517 us least of   9 runs  2.43
  naic, specamt solve : 2.139e-01 s mean;     212435 us least of   5 runs  2.32
  naic, ee prem solve : 2.024e-01 s mean;     198110 us least of   5 runs  2.36
  finra, no solve     : 2.958e-02 s mean;      29122 us least of  34 runs  1.42
  finra, specamt solve: 1.087e-01 s mean;     107460 us least of  10 runs  1.86
  finra, ee prem solve: 1.041e-01 s mean;     102665 us least of  10 runs  1.91

currency, with patch below:

Test speed:
  naic, no solve      : 7.284e-02 s mean;      72125 us least of  14 runs  1.42
  naic, specamt solve : 1.317e-01 s mean;     130443 us least of   8 runs  1.43
  naic, ee prem solve : 1.190e-01 s mean;     117681 us least of   9 runs  1.40
  finra, no solve     : 2.360e-02 s mean;      23285 us least of  43 runs  1.13
  finra, specamt solve: 7.287e-02 s mean;      72060 us least of  14 runs  1.25
  finra, ee prem solve: 6.995e-02 s mean;      69262 us least of  15 runs  1.29

This patch causes serious regressions. Its purpose is only to show
the effect of removing as much overhead from class currency as seems
possible.

diff --git a/currency.hpp b/currency.hpp
index 0a54a917..20123047 100644
--- a/currency.hpp
+++ b/currency.hpp
@@ -64,8 +64,8 @@ class currency
     ~currency() = default;
 
     explicit currency(double    d) : m_ {from_double(d)}           {}
-    explicit currency(int       i) : m_ {bourn_cast<data_type>(i)} {}
-    explicit currency(data_type i) : m_ {bourn_cast<data_type>(i)} {}
+    explicit currency(int       i) : m_ {static_cast<data_type>(i)} {}
+    explicit currency(data_type i) : m_ {static_cast<data_type>(i)} {}
 
     currency& operator=(currency const&) = default;
     // IMPORTANT eventually suppress this? or both of these?
@@ -131,7 +131,7 @@ class currency
     // ...less bad:
 //  data_type from_double(double d) const {return bourn_cast<data_type>(round(cents_per_dollar * d));}
     data_type from_double(double d) const {return round(cents_per_dollar * d);}
-    double to_double() const {return bourn_cast<double>(m_) / cents_per_dollar;}
+    double to_double() const {return static_cast<double>(m_) / cents_per_dollar;}
 //  data_type from_double(double d) const {return static_cast<data_type>(cents_per_dollar * d);}
 //  double to_double() const {return static_cast<double>(m_) / cents_per_dollar;}
 #if 0 // will a fwd decl be wanted somewhere?
@@ -143,7 +143,8 @@ class currency
 #else // 1
     data_type round(double d) const
         {
-        return bourn_cast<data_type>(std::round(d));
+//      return bourn_cast<data_type>(std::round(d));
+        return static_cast<data_type>(d);
         }
 #endif // 1
     data_type m_ = {0};
diff --git a/round_to.hpp b/round_to.hpp
index 84772dc8..59c37d49 100644
--- a/round_to.hpp
+++ b/round_to.hpp
@@ -390,7 +390,7 @@ inline currency round_to<RealType>::c(RealType r) const
         (rounding_function_(static_cast<RealType>(r * scale_fwd_)) * scale_back_c_
         );
     // include required headers
-    return currency(bourn_cast<currency::data_type>(z));
+    return currency(static_cast<currency::data_type>(z));
 #if 0
     // don't do this in production:
     if(z != std::trunc(z))
