Make conversions explicit, e.g.:
  currency amount;
- amount = 3.14;           // implicit
+ amount = currency(3.14); // explicit
  double floating;
- floating = amount;       // was implicit
+ floating = amount.d();
That may seem like mere ugly verbosity, but...
- amount = 0.0;            // (integer)(round(100.0 * 0.0))
+ amount = currency();     // integer = 0
+ currency amount {};      // even better, where possible
- if(0.0 == amount)        // 0.0 == (double)(amount / 100.0)
+ if(currency() == amount) // integer == integer
A user-defined literals like "0_c" could replace

Removed the very costly implicit conversions:
    currency& operator=(double d)
    operator double() const
but allowed
    currency& operator=(int i) // assigns 100.0 * argument

Because using integer math means not having to worry about catastrophic
cancellation, made improvements like this:

- LMI_ASSERT(materially_equal(GrossPmts[j], EeGrossPmts[j] + ErGrossPmts[j]));
+ LMI_ASSERT(GrossPmts[j] == EeGrossPmts[j] + ErGrossPmts[j]);

     double max_loan =
          AVUnloaned.d() * 0.9
        + (AVRegLn + AVPrfLn).d()
        - RegLnBal.d() * i_reg
        - PrfLnBal.d() * i_prf
        - mlydedtonextmodalpmtdate.d()
        ;

random notes--further cleanup and other future tasks:

+    if(currency() == RegLnBal && 0.0 == PrfLnBal)
                                  ^^^ should be "currency()"

max<double>...should rarely if ever need to specify template parameter

should be currency():
+    AVUnloaned               = 0;          // Antediluvian.

unary operator-()

loads class should use currency type for policy fees

probably DCV should be currency instead of double

Solves are still a puzzle: is it inherently slower to find an
integral root than a floating-point root of a polynomial? That
question is crucial because making solves dramatically slower
could mean that a currency class is unaffordable.

After the changes in this commit:

  naic, no solve      : 1.085e-01 s mean;     103995 us least of  10 runs
  naic, specamt solve : 1.798e-01 s mean;     179138 us least of   6 runs
  naic, ee prem solve : 1.672e-01 s mean;     166277 us least of   6 runs
  finra, no solve     : 2.711e-02 s mean;      26542 us least of  37 runs
  finra, specamt solve: 9.375e-02 s mean;      93087 us least of  11 runs
  finra, ee prem solve: 8.994e-02 s mean;      89230 us least of  12 runs

which is about ten percent faster for "finra, no solve", the
only scenario that involves no explicit or implicit solve,
so these improvements are valuable even if making all the
conversions explicit impairs readability somewhat. Still,
solves need to be looked at. Compared to production, even with
these changes the currency branch is thirty percent slower for the
"finra, no solve" case (yet further improvements might bring that
into an acceptable range), but only half as fast for the "naic"
scenarios (which involve solves).

//

As of
  commit 7bac50c7154a419ff93a1398313dc7fe6d9fbed5 (HEAD -> valyuta/002)
  Date:   2020-09-13T23:50:07+00:00
the currency class adds considerable overhead: about 42% in the
"finra, no solve" case, and much more in the other cases, which all
involve solves (even "naic, no solve" has a guaranteed-premium solve).
Thus, solves need to be looked at.

production:

  naic, no solve      : 5.122e-02 s mean;      50922 us least of  20 runs
  naic, specamt solve : 9.235e-02 s mean;      91375 us least of  11 runs
  naic, ee prem solve : 8.451e-02 s mean;      83933 us least of  12 runs
  finra, no solve     : 2.068e-02 s mean;      20534 us least of  49 runs
  finra, specamt solve: 5.816e-02 s mean;      57775 us least of  18 runs
  finra, ee prem solve: 5.385e-02 s mean;      53643 us least of  19 runs

currency, without patch below:

Test speed:
  naic, no solve      : 1.248e-01 s mean;     123517 us least of   9 runs  2.43
  naic, specamt solve : 2.139e-01 s mean;     212435 us least of   5 runs  2.32
  naic, ee prem solve : 2.024e-01 s mean;     198110 us least of   5 runs  2.36
  finra, no solve     : 2.958e-02 s mean;      29122 us least of  34 runs  1.42
  finra, specamt solve: 1.087e-01 s mean;     107460 us least of  10 runs  1.86
  finra, ee prem solve: 1.041e-01 s mean;     102665 us least of  10 runs  1.91

currency, with patch below:

Test speed:
  naic, no solve      : 7.284e-02 s mean;      72125 us least of  14 runs  1.42
  naic, specamt solve : 1.317e-01 s mean;     130443 us least of   8 runs  1.43
  naic, ee prem solve : 1.190e-01 s mean;     117681 us least of   9 runs  1.40
  finra, no solve     : 2.360e-02 s mean;      23285 us least of  43 runs  1.13
  finra, specamt solve: 7.287e-02 s mean;      72060 us least of  14 runs  1.25
  finra, ee prem solve: 6.995e-02 s mean;      69262 us least of  15 runs  1.29

This patch causes serious regressions. Its purpose is only to show
the effect of removing as much overhead from class currency as seems
possible.

diff --git a/currency.hpp b/currency.hpp
index 0a54a917..20123047 100644
--- a/currency.hpp
+++ b/currency.hpp
@@ -64,8 +64,8 @@ class currency
     ~currency() = default;
 
     explicit currency(double    d) : m_ {from_double(d)}           {}
-    explicit currency(int       i) : m_ {bourn_cast<data_type>(i)} {}
-    explicit currency(data_type i) : m_ {bourn_cast<data_type>(i)} {}
+    explicit currency(int       i) : m_ {static_cast<data_type>(i)} {}
+    explicit currency(data_type i) : m_ {static_cast<data_type>(i)} {}
 
     currency& operator=(currency const&) = default;
     // IMPORTANT eventually suppress this? or both of these?
@@ -131,7 +131,7 @@ class currency
     // ...less bad:
 //  data_type from_double(double d) const {return bourn_cast<data_type>(round(cents_per_dollar * d));}
     data_type from_double(double d) const {return round(cents_per_dollar * d);}
-    double to_double() const {return bourn_cast<double>(m_) / cents_per_dollar;}
+    double to_double() const {return static_cast<double>(m_) / cents_per_dollar;}
 //  data_type from_double(double d) const {return static_cast<data_type>(cents_per_dollar * d);}
 //  double to_double() const {return static_cast<double>(m_) / cents_per_dollar;}
 #if 0 // will a fwd decl be wanted somewhere?
@@ -143,7 +143,8 @@ class currency
 #else // 1
     data_type round(double d) const
         {
-        return bourn_cast<data_type>(std::round(d));
+//      return bourn_cast<data_type>(std::round(d));
+        return static_cast<data_type>(d);
         }
 #endif // 1
     data_type m_ = {0};
diff --git a/round_to.hpp b/round_to.hpp
index 84772dc8..59c37d49 100644
--- a/round_to.hpp
+++ b/round_to.hpp
@@ -390,7 +390,7 @@ inline currency round_to<RealType>::c(RealType r) const
         (rounding_function_(static_cast<RealType>(r * scale_fwd_)) * scale_back_c_
         );
     // include required headers
-    return currency(bourn_cast<currency::data_type>(z));
+    return currency(static_cast<currency::data_type>(z));
 #if 0
     // don't do this in production:
     if(z != std::trunc(z))
