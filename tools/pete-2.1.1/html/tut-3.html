<!-- tut-3.html : third PETE tutorial -->
<!-- $Id: tut-3.html,v 1.7 1999/10/29 22:30:29 sa_smith Exp $ -->

<html>
<head>
<title>PETE Tutorial 3: Synthesizing Types</title>
</head>
<body bgcolor="#ffffff" link="#0099cc" alink="#0099cc" vlink="#cc6600">

<h1><center><img src="banner.gif" width="432" height="108" align="BOTTOM"
border="0" naturalsizeflag="3"></CENTER></h1>

<center><h1>PETE Tutorial 3<br>Synthesizing Types</h1></center>

<p><b>Contents:</b>
<br>&nbsp;&nbsp;&nbsp;&nbsp;<a href="#intro">Introduction</a>
<br>&nbsp;&nbsp;&nbsp;&nbsp;<a href="#surface">On the Surface</a>
<br>&nbsp;&nbsp;&nbsp;&nbsp;<a href="#details">Under the Hood</a>
<br>&nbsp;&nbsp;&nbsp;&nbsp;<a href="#summary">Summary</a>
<br>&nbsp;&nbsp;&nbsp;&nbsp;<a href="#source-files">Source Files</a>
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#rgb-h"><tt>RGB.h</tt></a>
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#rgbdefs-in"><tt>RGBDefs.in</tt></a>
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#rgb-cpp"><tt>RGB.cpp</tt></a>

<!---------------------------------------------------------------------->
<a name="intro"><h2>Introduction</h2></a>

<p>This tutorial shows how to use PETE to perform non-arithmetic
operations on a program as it is being compiled, and in particular how
to synthesize new types and values by extending PETE's specialized
templates and operator overloadings.  The problem domain is the three
primary colors---red, green, and blue---which are combined according
to three simple rules:
<ul>
<li>red and green give blue;
<li>red and blue give green; and
<li>green and blue give red.
</ul>
While these rules are trivial, the techniques shown below can be used
to make compilers optimize much more complex expressions on more
complicated domains.

<p>The source files for this example are included in the
<tt>examples/RGB</tt> directory of the PETE distribution.  These files
are:

<ul>

<li><a href="#rgb-h"><tt>RGB.h</tt></a>: defines the tag classes used
in the example to represent colors, and the rules used to combine
them.

<li><a href="#rgbdefs-in"><tt>RGBDefs.in</tt></a>: definitions needed
to automatically generate the overloaded operators required to
integrate the color classes into PETE.  As in the <a
href="#tut-1.html#make-expr-operators">first tutorial</a>, this file
is processed by the <tt>MakeOperators</tt> tool to create a header
file.

<li><tt>RGBOperators.h</tt>: the file generated by
<tt>MakeOperators</tt> based on the definitions in
<tt>RGBDefs.in</tt>.  The file <tt>RGB.h</tt> <tt>#include</tt>s
<tt>RGBOperators.h</tt>, so that PETE-based programs only need to
<tt>#include</tt> <tt>RGB.h</tt>, rather than both <tt>RGB.h</tt> and
<tt>RGBOperators.h</tt>.

<li><a href="#rgb-cpp"><tt>RGB.cpp</tt></a>: a short program that
shows how to use the definitions in the header files described above
to create values during compilation.

<li><tt>makefile</tt>: rebuilds the example.

</ul>

<!---------------------------------------------------------------------->
<a name="surface"><h2>On the Surface</h2></a>

<p>PETE was created to make it easy for programmers to extend
expression templates.  In particular, PETE lets programmers specify a
wide range of computations that are to be carried out as the program
is being compiled.  To do this, the programmer must provide three
things: the type(s) of object(s) to be operated on, the functor(s) to
be used to extract values from those objects, and the combiner(s) to
be used to process those values.

<p>In our example, the values being manipulated are the three primary
colors red, green, and blue.  Each color is represented by an empty
tag class, whose only purpose is to act as a strongly-typed
placeholder as the compiler is instantiating templates.  The three
classes are defined at the top of <a href="#rgb-h"><tt>RGB.h</tt></a>:

<blockquote><pre>
017  struct Red { };
018  struct Green { };
019  struct Blue { };
</pre></blockquote>

<p>Our example defines a single functor, called <tt>GetColor</tt>.
Like <tt>Red</tt>, <tt>Green</tt>, and <tt>Blue</tt>,
<tt>GetColor</tt> is an empty class, no instances of which are ever
actually created by a running program.

<p>In addition, <a href="#rgb-h"><tt>RGB.h</tt></a> defines one more
empty tag class, called <tt>ColorCombine</tt>.  This tag is used to
signal to the compiler that we are combining colors, rather than (for
example) adding vectors.  The two definitions are:

<blockquote><pre>
020  struct GetColor { };
021  struct ColorCombine { };
</pre></blockquote>

<p>We have one more empty class to define in order to begin building
our computational framework.  The class <tt>Operand&lt;&gt;</tt>
serves as a wrapper around color expressions; its purpose is to
identify those expressions by giving them a well-known overall type.
<tt>Operand&lt;&gt;</tt> is therefore similar to the generic PETE
expression class <tt>Expression&lt;&gt;</tt>, which is used to
distinguish PETE expressions from other types of expressions.  In our
case, the <tt>Operand&lt;&gt;</tt> class is used only to wrap up a
color expression:

<blockquote><pre>
109  template&lt;class ColorTag&gt;
110  struct Operand
111 {
       // <em>body is empty</em>
112  };
</pre></blockquote>

<p>We must now tell PETE how to store an <tt>Operand&lt;&gt;</tt>
value in the leaf of an expression tree.  The required definition is:

<blockquote><pre>
119  template&lt;class ColorTag&gt;
120  struct CreateLeaf&lt;Operand&lt;ColorTag&gt; &gt;
121  {
122    typedef Operand&lt;ColorTag&gt; Leaf_t;
123    inline static
124    const Leaf_t &amp;make(const Operand&lt;ColorTag&gt; &amp;a) { return a; }
125  };
</pre></blockquote>

<p>Note how the formal class name used in the template header,
<tt>ColorTag</tt>, appears as an argument to <tt>Operand&lt;&gt;</tt>
in the formal parameter list of the <tt>CreateLeaf&lt;&gt;</tt>
specialization.  This ensures that our definition only applies to
properly-formed <tt>Operand&lt;&gt;</tt>s.

<p>Note also the <tt>typedef</tt> inside this specialization of
<tt>CreateLeaf&lt;&gt;</tt>.  PETE's template specialization rules
require every specialization of <tt>CreateLeaf&lt;&gt;</tt> to have a
<tt>typedef</tt> called <tt>Leaf_t</tt>, which specifies the type of
the leaf node.  This is also the declared return type of the
<tt>static</tt> method <tt>make()</tt>, which constructs a leaf node
given an actual object (in this case, a color class instance).

<p><tt>CreateLeaf&lt;&gt;</tt> tells PETE how to store values in leaf
nodes; specializations of <tt>LeafFunctor&lt;&gt;</tt> tell PETE how
to apply a user-defined functor to those nodes to obtain a value.  As
before, we template our specialization of <tt>LeafFunctor&lt;&gt;</tt>
on a formal parameter that will be filled in with a color class, but
then nest that formal parameter inside <tt>Operand&lt;&gt;</tt> in
order to ensure that the compiler only tries to use this
specialization of <tt>LeafFunctor&lt;&gt;</tt> on the right kinds of
expressions.

<p><tt>LeafFunctor&lt;&gt;</tt> takes a second template parameter,
which is the functor that is being applied to the leaf node.  In our
case, we have defined only one functor on colors, namely
<tt>GetColor</tt>.  Our specialization is therefore:

<blockquote><a name="leaf-functor"><pre>
132  template&lt;class Color&gt;
133  struct LeafFunctor&lt;Operand&lt;Color&gt;, GetColor&gt;
134  {
135    typedef Color Type_t;
136  };
</pre></blockquote>

<p>Unlike the <tt>LeafFunctor&lt;&gt;</tt> specializations in previous
tutorials, notice that this version does not have an <tt>apply()</tt> 
method. The reason is that we're using this functor only for compile-time
type calculations. We're never going to call <tt>apply()</tt> so we
therefore don't need to go to the trouble of defining it.

<p>Our last task is to define some specializations of
<tt>Combine2&lt;&gt;</tt>, the combiner that PETE uses to operate on
values in binary expressions.  Six specializations are defined, for
each possible ordered combination of different color values.  The
combiner for <tt>Red</tt> and <tt>Green</tt> is:

<blockquote><a name="combine-2"><pre>
063  template&lt;class Op&gt;
064  struct Combine2&lt;Red, Green, Op, ColorCombine&gt;
065  {
066    typedef Blue Type_t;
       // <em>not required</em>  inline static
       // <em>not required</em>  Type_t combine(Red, Green, Op, ColorCombine)
       // <em>not required</em>  {
       // <em>not required</em>    return Blue();
       // <em>not required</em>  }
067  };
</pre></blockquote>

<p>The generic form of <tt>Combine2&lt;&gt;</tt> takes four template
parameters: the classes of its operands, a tag identifying the C++
operator from which the expression was created (such as <tt>OpAdd</tt>
or <tt>OpMultiply</tt>), and a user-defined tag, which can be used to force
the compiler to calculate a different expression than the one
apparently specified.  In the case of this example, the first two
parameters specify the colors being combined, while the last parameter
signals that these values are being combined according to our own
rules.  This is the only use for <tt>ColorCombine</tt>.  The formal
template parameter <tt>Op</tt> is not referenced anywhere in this
class, so that <em>any</em> binary operation on colors, including
addition, multiplication, bitwise OR, or left shift, will use the
user-defined rules.

<p>Combiners typically have two elements: a type <tt>Type_t</tt> that
gives the type of object formed by combining the operands and a
<tt>combine</tt> methods that takes the operands and does whatever
is necessary to produce a <tt>Type_t</tt> object. Like the 
<tt>LeafFunctor&lt;&gt;</tt> specialization above, we don't need the
<tt>combine</tt> method here since we're synthesizing types. However,
we've shown what this function would look like if it were necessary to
define it.

<p>We can now test that our definitions do the right thing by defining
three functions to print out the color of an expression involving
colors.  The function for <tt>Red</tt> takes a constant reference to a
<tt>Red</tt> object, and prints a simple string:

<blockquote><pre>
027  inline void calc(const Red &amp;)
028  {
029    cout &lt;&lt; "This expression is red." &lt;&lt; endl;
030  }
</pre></blockquote>

<p>The other two overloadings of this function, which are defined on
lines 32-40 for the tag classes <tt>Green</tt> and <tt>Blue</tt>,
print out "green" and "blue" instead of "red".

<p>Finally, the templated function <tt>printColor&lt;&gt;()</tt> takes
an expression, evaluates it <em>during compilation</em> by forcing the
compiler to expand the expression using our <tt>GetColor</tt> and
<tt>ColorCombine</tt> tags, and then uses the deduced color of the
expression to select a version of <tt>calc()</tt>, which prints out
that color's name.  The whole definition is:

<blockquote><pre>
048  template &lt;class Expr&gt;
049  void printColor(const Expression&lt;Expr&gt; &amp;expr)
050  {
051    typedef typename ForEach&lt;Expression&lt;Expr&gt;, GetColor, ColorCombine&gt;::Type_t 
052      DeducedColor_t;
053    
054    calc(DeducedColor_t());
055  }
</pre></blockquote>

<p>It is worth looking at this function definition closely.  The
expansion of <tt>CreateLeaf&lt;&gt::Leaf_t</tt> extracts and formats
the type of the expression according to our color-based evaluation
rules.  The expansion of the PETE-defined template
<tt>ForEach&lt;&gt;</tt> does most of the work.  During its expansion,
the functor and combiner tags are passed down the parse tree. They are
used to extract types from the leaves of the parse tree. These types
are combined at non-leaf nodes to produce new types, which are passed
up the parse tree. The result is a type---<tt>Red</tt>, <tt>Green</tt>,
or <tt>Blue</tt>---that is labelled by <tt>DeducedColor_t</tt>. This
type, in turn, triggers instantiation of an appropriate version of
<tt>calc()</tt>.

<!---------------------------------------------------------------------->
<a name="details"><h2>Under the Hood</h2></a>

<p>Let's take a closer look at exactly what happens when
<tt>printColor()</tt> is instantiated with a color expression, as it
is at the start of the test program in <a
href="#rgb-cpp"><tt>RGB.cpp</tt></a>:

<blockquote><pre>
005    printColor(Operand&lt;Red&gt;() + Operand&lt;Green&gt;());
</pre></blockquote>

<p>Let's start with the automatically-generated operator overloadings
in <tt>RGBOperators.h</tt>, which are created using the
<tt>MakerOperators</tt> tool described in the <a
href="tut-1.html#make-expr-operators">first tutorial</a>.  The
overloading for <tt>operator+</tt> is:

<blockquote><pre>
618  template&lt;class T1,class T2&gt;
619  inline typename MakeReturn&lt;BinaryNode&lt;OpAdd,
620    typename CreateLeaf&lt;Operand&lt;T1&gt; &gt;::Leaf_t,
621    typename CreateLeaf&lt;Operand&lt;T2&gt; &gt;::Leaf_t,
622    StoreByRefTag&gt; &gt;::Expression_t
623  operator+(const Operand&lt;T1&gt; &amp; l,const Operand&lt;T2&gt; &amp; r)
624  {
625    typedef BinaryNode&lt;OpAdd,
626      typename CreateLeaf&lt;Operand&lt;T1&gt; &gt;::Leaf_t,
627      typename CreateLeaf&lt;Operand&lt;T2&gt; &gt;::Leaf_t,
628      StoreByRefTag&gt; Tree_t;
629    return MakeReturn&lt;Tree_t&gt;::make(Tree_t(
630      CreateLeaf&lt;Operand&lt;T1&gt; &gt;::make(l),
631      CreateLeaf&lt;Operand&lt;T2&gt; &gt;::make(r)));
632  }
</pre></blockquote>

<p>Once again, there is less going on here than first meets the eye.
We are trying to perform computations using C++ template notation, a
job for which that notation was not designed.  The first things to
look at are the uses of <tt>CreateLeaf&lt;&gt;::Leaf_t</tt>.  As we
saw above, in the case of an <tt>Operand&lt;&gt;</tt> with a color
type argument, <tt>Leaf_t</tt> is just the color type argument wrapped
in an <tt>Operand&lt;&gt;</tt> type; the
<tt>CreateLeaf&lt;&gt;</tt> indirection is provided to give
programmers a hook for doing other things if they so desire.  This
means that we can simplify the code above as:

<blockquote><pre>
618  template&lt;class T1,class T2&gt;
619  inline typename MakeReturn&lt;BinaryNode&lt;OpAdd,
620    Operand&lt;T1&gt;,
621    Operand&lt;T2&gt;,
622    StoreByRefTag&gt; &gt;::Expression_t
623  operator+(const Operand&lt;T1&gt; &amp; l,const Operand&lt;T2&gt; &amp; r)
624  {
625    typedef BinaryNode&lt;OpAdd,
626      Operand&lt;T1&gt;,
627      Operand&lt;T2&gt;,
628      StoreByRefTag&gt; Tree_t;
629    return MakeReturn&lt;Tree_t&gt;::make(Tree_t(
630      CreateLeaf&lt;Operand&lt;T1&gt; &gt;::make(l),
631      CreateLeaf&lt;Operand&lt;T2&gt; &gt;::make(r)));
632  }
</pre></blockquote>

<p>By referring back to the arguments of <tt>printColor()</tt>, we can
replace <tt>T1</tt> with <tt>Red</tt>, and <tt>T2</tt> with
<tt>Green</tt>:

<blockquote><pre>
619  inline typename MakeReturn&lt;BinaryNode&lt;OpAdd,
620    Operand&lt;Red&gt;,
621    Operand&lt;Green&gt;,
622    StoreByRefTag&gt; &gt;::Expression_t
623  operator+(const Operand&lt;Red&gt; &amp; l,const Operand&lt;Green&gt; &amp; r)
624  {
625    typedef BinaryNode&lt;OpAdd,
626      Operand&lt;Red&gt;,
627      Operand&lt;Green&gt;,
628      StoreByRefTag&gt; Tree_t;
629    return MakeReturn&lt;Tree_t&gt;::make(Tree_t(
630      CreateLeaf&lt;Operand&lt;Red&gt; &gt;::make(l),
631      CreateLeaf&lt;Operand&lt;Green&gt; &gt;::make(r)));
632  }
</pre></blockquote>

<p>Looking back at <tt>CreateLeaf&lt;&gt;</tt> once more, we see that
its <tt>make()</tt> method simply returns its argument.  (In the case
of STL containers, <tt>make()</tt> could return an iterator over its
argument.)  Our operator thus becomes simpler still:

<blockquote><pre>
619  inline typename MakeReturn&lt;BinaryNode&lt;OpAdd,
620    Operand&lt;Red&gt;,
621    Operand&lt;Green&gt;,
622    StoreByRefTag&gt; &gt;::Expression_t
623  operator+(const Operand&lt;Red&gt; &amp; l,const Operand&lt;Green&gt; &amp; r)
624  {
625    typedef BinaryNode&lt;OpAdd,
626      Operand&lt;Red&gt;,
627      Operand&lt;Green&gt;,
628      StoreByRefTag&gt; Tree_t;
629    return MakeReturn&lt;Tree_t&gt;::make(Tree_t(l, r));
632  }
</pre></blockquote>

<p>To simplify this further, we must turn to the definition of
<tt>MakeReturn&lt;&gt;</tt> in PETE's <tt>CreateLeaf.h</tt>:

<blockquote><pre>
136  template&lt;class T&gt;
137  struct MakeReturn
138  {
139    typedef Expression&lt;T&gt; Expression_t;
140    inline static
141    Expression_t make(const T &amp;a) { return Expression_t(a); }
142  };
</pre></blockquote>

<p>The default expansion of <tt>MakeReturn&lt;T&gt;::Expression_t</tt>
is simply <tt>Expression&lt;T&gt;</tt>, and
<tt>MakeReturn&lt;&gt;</tt>'s <tt>make()</tt> method just returns its
argument, appropriately typed.  This may seem unnecessary, but as the
PETE header files themselves explain:

<blockquote>
<tt>MakeReturn&lt;&gt;</tt> is used to wrap expression objects
(<tt>UnaryNode&lt;&gt;</tt>, <tt>BinaryNode&lt;&gt;</tt> etc.) inside
an <tt>Expression&lt;&gt;</tt> object.  Usually this indirection is
unnecessary, but the indirection allows users to specify their own
approach to storing trees.  By specializing
<tt>MakeReturn&lt;UnaryNode&lt;&gt;&gt;</tt>,
<tt>MakeReturn&lt;BinaryNode&lt;&gt;&gt;</tt>, etc. you could cause
the expression trees to be stored in another format.  For example,
POOMA stores expressions inside <tt>Array</tt>s, so the result of
<tt>Array+Array</tt> is another <tt>Array</tt>.
</blockquote>

<p>We can now expand our operator one more level:

<blockquote><pre>
623  operator+(const Operand&lt;Red&gt; &amp; l,const Operand&lt;Green&gt; &amp; r)
624  {
625    typedef BinaryNode&lt;OpAdd,
626      Operand&lt;Red&gt;,
627      Operand&lt;Green&gt;,
628      StoreByRefTag&gt; Tree_t;
629    return Expression&lt;Tree_t&gt;(Tree_t(l, r));
632  }
</pre></blockquote>

<p>Note that we are no longer bothering to show the return type of the
function, since it is the same as the type of the <tt>return</tt>
statement inside the function body.

<p>With this in hand, let's return to <tt>printColor()</tt>:

<blockquote><pre>
048  template &lt;class Expr&gt;
049  void printColor(const Expression&lt;Expr&gt; &amp;expr)
050  {
051    typedef typename ForEach&lt;Expression&lt;Expr&gt;, GetColor, ColorCombine&gt;::Type_t 
052      DeducedColor_t;
053    
054    calc(DeducedColor_t());
055  }
</pre></blockquote>

<p>The formal parameter <tt>expr</tt> is an instance of
<tt>Expression&lt;BinaryNode&lt;OpAdd,Operand&lt;Red&gt;,Operand&lt;Green&gt;,StoreByRefTag&gt; &gt;</tt>,
with an <tt>Operand&lt;Red&gt;</tt> and a <tt>Operand&lt;Green&gt;</tt> as its left and right
members. This type is passed to PETE's <tt>ForEach</tt> class. We this class rather than
the <tt>forEach</tt> function because we are synthesizing types. Referring to the PETE 
header file <tt>ForEach.h</tt>, we see that the most specific matching definition is:

<blockquote><pre>
146  template&lt;class T, class FTag, class CTag&gt;
147  struct ForEach&lt;Expression&lt;T&gt;, FTag, CTag&gt;
148  {
149    typedef typename ForEach&lt;T, FTag, CTag&gt;::Type_t Type_t;
150    inline static
151    Type_t apply(const Expression&lt;T&gt; &amp;expr, const FTag &f, 
152                 const CTag &amp;c) 
153    {
154      return ForEach&lt;T, FTag, CTag&gt;::apply(expr.expression(), f, c);
155    }
156  };
</pre></blockquote>

<p> As we've mentioned, we are synthesizing types in this example so the <tt>apply</tt>
function (lines 150-155) will never actually be called. Therefore, in subsequent 
definitions, we'll omit this for brevity. The important thing to note is that
the <tt>typedef</tt> of <tt>Type_t</tt> is generated by extracting the type
wrapped by the <tt>Expression&lt;&gt;</tt> object and using that in another
<tt>ForEach</tt>. Recall that this wrapped type in our example is
<tt>BinaryNode&lt;OpAdd,Operand&lt;Red&gt;,Operand&lt;Green&gt;,StoreByRefTag&gt;</tt>.
This means that the relevant <tt>ForEach</tt> definition is
 
<blockquote><pre>
107  template&lt;class Op, class A, class B, class ST, class FTag, class CTag&gt;
108  struct ForEach&lt;BinaryNode&lt;Op, A, B, ST&gt;, FTag, CTag &gt;
109  {
110    typedef typename ForEach&lt;A, FTag, CTag&gt;::Type_t TypeA_t;
111    typedef typename ForEach&lt;B, FTag, CTag&gt;::Type_t TypeB_t;
112    typedef typename Combine2&lt;TypeA_t, TypeB_t, Op, CTag&gt;::Type_t Type_t;
122  };
</pre></blockquote>

<p> Now is a good time to perform some type substitutions. The result is

<blockquote><pre>
107  template&lt;&gt;
108  struct ForEach&lt;BinaryNode&lt;OpAdd,Operand&lt;Red&gt;,Operand&lt;Green&gt;,StoreByRefTag&gt;, OpAdd, GetColor, ColorCombine&gt;
109  {
110    typedef ForEach&lt;Operand&lt;Red&gt;, GetColor, ColorCombine&gt;::Type_t TypeA_t;
111    typedef ForEach&lt;Operand&lt;Green&gt;, GetColor, ColorCombine&gt;::Type_t TypeB_t;
112    typedef Combine2&lt;TypeA_t, TypeB_t, OpAdd, ColorCombine&gt;::Type_t Type_t;
122  };
</pre></blockquote>

<p> To proceed, we need to resolve the <tt>ForEach</tt> types in lines 110 and 111. 
Looking through <tt>ForEach.h</tt>, we see that the only partial specialization that
matches is the most general version of <tt>ForEach</tt>:

<blockquote><pre>
074  template&lt;class Expr, class FTag, class CTag&gt;
075  struct ForEach
076  {
077    typedef typename LeafFunctor&lt;Expr, FTag&gt;::Type_t Type_t;
083  };
</pre></blockquote>

<p> This version of <tt>ForEach</tt> is meant to be used for leaves. It simply 
passes the task to the <tt>LeafFunctor</tt> class. Substituting this above gives:

<blockquote><pre>
107  template&lt;&gt;
108  struct ForEach&lt;BinaryNode&lt;OpAdd,Operand&lt;Red&gt;,Operand&lt;Green&gt;,StoreByRefTag&gt;, OpAdd, GetColor, ColorCombine&gt;
109  {
110    typedef LeafFunctor&lt;Operand&lt;Red&gt;, GetColor&gt;::Type_t TypeA_t;
111    typedef LeafFunctor&lt;Operand&lt;Green&gt;, GetColor&gt;::Type_t TypeB_t;
112    typedef Combine2&lt;TypeA_t, TypeB_t, OpAdd, ColorCombine&gt;::Type_t Type_t;
122  };
</pre></blockquote>

<p>This is starting to look promising: we now have some invocations of
<tt>Combine2&lt;&gt;</tt>, the combiner that was overridden in <a
href="#rgb-h"><tt>RGB.h</tt></a>, and some uses of
<tt>LeafFunctor&lt;&gt;</tt>, which was also overridden.  In fact, as
we saw <a href="#leaf-functor">earlier</a>, when
<tt>LeafFunctor&lt;&gt;</tt> has an <tt>Operand&lt;&gt;</tt> as 
its first type argument, and the <tt>GetColor</tt> functor tag as its 
second argument, its <tt>Type_t</tt> definition is just its color 
argument.  We can therefore simplify the definition of <tt>ForEach&lt;&gt;</tt> on
binary nodes to be:

<blockquote><pre>
107  template&lt;&gt;
108  struct ForEach&lt;BinaryNode&lt;OpAdd,Operand&lt;Red&gt;,Operand&lt;Green&gt;,StoreByRefTag&gt;, OpAdd, GetColor, ColorCombine&gt;
109  {
112    typedef Combine2&lt;Red, Green, OpAdd, ColorCombine&gt;::Type_t Type_t;
122  };
</pre></blockquote>

<p> The compiler can now match the specialized definition of
<tt>Combine2&lt;&gt;</tt> shown <a href="#combine-2">earlier</a>
against this code. Thus, the return type of the expansion of <tt>ForEach&lt;&gt;</tt>
inside of <tt>printColor</tt> is <tt>Blue</tt>. This, in turn, is used to select
the <tt>calc<Blue>()</tt> function, which simply prints out the word "blue".

<p> This may seem like a lot of work simply to print out a different word.
However, it illustrates an extremely powerful capability of PETE: selecting
custom algorithms at compile time based on the a synthesized type. All of the
type computations outlined above are performed at compile-time. Also, the
various <tt>calc</tt> functions are inlined. This means that the compiler
will generate a custom <tt>printColor</tt> function for our expression that
is equivalent to

<blockquote><pre>
048  template &lt&gt;
049  void printColor(const Expression&lt;BinaryNode&lt;OpAdd,Operand&lt;Red&gt;,Operand&lt;Green&gt;,StoreByRefTag&gt; &gt; &amp;expr)
050  {
054    cout &lt;&lt; "This expression is blue." &lt;&lt; endl;
055  }
</pre></blockquote>

<p> This is an example of <em>compile-time polymorphism</em>. We've used the C++ compiler
to generate special code based on the types we pass into a function rather than making
a run-time choice of a function to call. This can lead to the generation of extremely
efficient code.

<!---------------------------------------------------------------------->
<a name="summary"><h2>Summary</h2></a>

<p>This tutorial has shown how to extend PETE to synthesize type
information during compilation by performing symbolic manipulations on
parse trees.  The user-level definitions required are more complex
than those needed to use PETE simply to optimize expression
evaluation, but tracing through their operation shows how PETE
exploit's the C++ compiler's pattern matching and type expansion
facilities to do what it does.

<!---------------------------------------------------------------------->
<a name="source-files"><h2>Source Files</h2></a>

<! - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ->
<a name="rgb-h"><h3><tt>RGB.h</tt></h3></a>

<blockquote><pre><!-- start-line-numbering -->
001  #ifndef PETE_EXAMPLES_RGB_RGB_H
002  #define PETE_EXAMPLES_RGB_RGB_H
003
004  //-----------------------------------------------------------------------------
005  // Include files
006  //-----------------------------------------------------------------------------
007
008  #include &lt;iostream.h&gt;
009
010  #include "PETE/PETE.h"
011
012  //-----------------------------------------------------------------------------
013  // Tag classes representing colors. Also, a functor for getting a color from
014  // a leaf and a combiner for combining colors.
015  //-----------------------------------------------------------------------------
016
017  struct Red { };
018  struct Green { };
019  struct Blue { };
020  struct GetColor { };
021  struct ColorCombine { };
022
023  //-----------------------------------------------------------------------------
024  // A few overloaded functions that print out color names given a type.
025  //-----------------------------------------------------------------------------
026
027  inline void calc(const Red &amp;)
028  {
029    cout &lt;&lt; "This expression is red." &lt;&lt; endl;
030  }
031
032  inline void calc(const Blue &amp;)
033  {
034    cout &lt;&lt; "This expression is blue." &lt;&lt; endl;
035  }
036
037  inline void calc(const Green &amp;)
038  {
039    cout &lt;&lt; "This expression is green." &lt;&lt; endl;
040  }
041
042  //-----------------------------------------------------------------------------
043  // A function that deduces a color at compile time and calls a special
044  // function based on the value.
045  //
046  //-----------------------------------------------------------------------------
047
048  template &lt;class Expr&gt;
049  void printColor(const Expression&lt;Expr&gt; &amp;expr)
050  {
051    typedef typename ForEach&lt;Expression&lt;Expr&gt;, GetColor, ColorCombine&gt;::Type_t 
052      DeducedColor_t;
053    
054    calc(DeducedColor_t());
055  }
056
057  //-----------------------------------------------------------------------------
058  // A set of combiners that produce new colors according to some arbitrary
059  // rules: red &amp; green give blue, red &amp; blue give green, blue and green give 
060  // red.
061  //-----------------------------------------------------------------------------
062
063  template&lt;class Op&gt;
064  struct Combine2&lt;Red, Green, Op, ColorCombine&gt;
065  {
066    typedef Blue Type_t;
067  };
068
069  template&lt;class Op&gt;
070  struct Combine2&lt;Red, Blue, Op, ColorCombine&gt;
071  {
072    typedef Green Type_t;
073  };
074
075  template&lt;class Op&gt;
076  struct Combine2&lt;Green, Blue, Op, ColorCombine&gt;
077  {
078    typedef Red Type_t;
079  };
080
081  template&lt;class Op&gt;
082  struct Combine2&lt;Green, Red, Op, ColorCombine&gt;
083  {
084    typedef Blue Type_t;
085  };
086
087  template&lt;class Op&gt;
088  struct Combine2&lt;Blue, Green, Op, ColorCombine&gt;
089  {
090    typedef Red Type_t;
091  };
092
093  template&lt;class Op&gt;
094  struct Combine2&lt;Blue, Red, Op, ColorCombine&gt;
095  {
096    typedef Green Type_t;
097  };
098
099  template&lt;class C1, class C2, class Op&gt;
100  struct Combine2&lt;C1, C2, Op, ColorCombine&gt;
101  {
102    typedef C1 Type_t;
103  };
104
105  //-----------------------------------------------------------------------------
106  // A class that has a single template parameter that specifies a color.
107  //-----------------------------------------------------------------------------
108
109  template&lt;class ColorTag&gt;
110  struct Operand
111  {
112  };
113
114  //-----------------------------------------------------------------------------
115  // We need to specialize CreateLeaf&lt;T&gt; for Operand, so that operators
116  // know what to stick in the leaves of the expression tree.
117  //-----------------------------------------------------------------------------
118
119  template&lt;class ColorTag&gt;
120  struct CreateLeaf&lt;Operand&lt;ColorTag&gt; &gt;
121  {
122    typedef Operand&lt;ColorTag&gt; Leaf_t;
123    inline static
124    const Leaf_t &amp;make(const Operand&lt;ColorTag&gt; &amp;a) { return a; }
125  };
126
127  //-----------------------------------------------------------------------------
128  // Specialization of LeafFunctor class for applying the getting the "color"
129  // of an operand.
130  //-----------------------------------------------------------------------------
131
132  template&lt;class Color&gt;
133  struct LeafFunctor&lt;Operand&lt;Color&gt;, GetColor&gt;
134  {
135    typedef Color Type_t;
136  };
137
138  #include "RGBOperators.h"
139
140  #endif // PETE_EXAMPLES_RGB_RGB_H
</pre></blockquote><!-- end-line-numbering -->

<! - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ->
<a name="rgbdefs-in"><h3><tt>RGBDefs.in</tt></h3></a>

<blockquote><pre><!-- start-line-numbering -->
001  classes
002  -----
003    ARG   = "class T[n]"
004    CLASS = "Operand&lt;T[n]&gt;"
</pre></blockquote><!-- end-line-numbering -->

<! - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ->
<a name="rgb-cpp"><h3><tt>RGB.cpp</tt></h3></a>

<blockquote><pre><!-- start-line-numbering -->
001  #include "RGB.h"
002  
003  int main()
004  {
005    printColor(Operand&lt;Red&gt;() + Operand&lt;Green&gt;());
006    printColor(Operand&lt;Red&gt;() + Operand&lt;Green&gt;() + Operand&lt;Blue&gt;());
007    printColor(Operand&lt;Red&gt;() + (Operand&lt;Green&gt;() + Operand&lt;Blue&gt;()));
008  }
</pre></blockquote><!-- end-line-numbering -->

<br>
<br>
<center>
<table>
<tr>	<td><a href="tut-2.html">[Prev]</a>
	<td><a href="index.html">[Home]</a>
	<td><a href="stl.html">[Next]</a>
	</tr>
</table>
<em>
<a href="http://www.acl.lanl.gov/pete/">Copyright &copy; Los Alamos National Laboratory 1999</a>
</em>
</center>

</body>
</html>
